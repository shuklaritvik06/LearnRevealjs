<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Blockchain</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background-image="./assets/Blockchain.jpg"></section>
			<section data-markdown>
				<textarea data-template>
					## History of Blockchain
				</textarea>
			</section>
			<section>Two researchers Stuart Haber and W. Scott Stornetta introduced the Blockchain technology in 1991.
				They wanted to have a solution for the digital timestamping of the documents, so anyone cannot tamper
				it, so they developed a system where these time stamped documents were stored in a Chain of Blocks.
			</section>
			<section>But here in this system a single document could be stored in a block, so in 1992 Merkle Trees,
				Haber and Stornetta formed a legal corporation which improved the efficiency of the current system, Now
				the system was efficient to store several documents in a single block, which was not the case in 1991.
			</section>
			<section>In 2004 Hal Finney introduced Reusable Proof of work. Reusable proof of work was based on Hashcash
			</section>
			<section>Hashcash was to help avoid losing email due to content based and blacklist based anti-spam systems.
				Hashcash tool was used to verify stamps attached to emails that we send, and one attached to emails we
				receive. Email senders attached hashcash stamps to the header.</section>
			<section>Reusable proof of work tokens are not tied to a particular application but can be freely spent as
				if they are a currency. Customers can create tokens by running a proof of work. The value of a token is
				determined by the resources spent in its creation.</section>
			<section>When the user decides to spend the token, he sends it to another user, who redeems it in a RPOW
				server that marks it and turns it into another new token.This system depends on a server that maintains
				a database with all the tokens spent.</section>
			<section>This server cannot create tokens, it only reissues tokens when a previously unspent token is
				presented. After this in 2008 Satoshi Nakamoto (Believed Creator of Bitcoin) introduced the peer-to-peer
				concept of timestamping, and created a system that is more secure.</section>
			<section>
				<h2 class="r-fit-text">What is Blockchain?</h2>
			</section>
			<section>Blockchain is an immutable distributed ledger which record the transactions.</section>
			<section>Suppose you have a notebook of topper, which have all the imp questions for exam, and you share a
				copy of that with all your classmates. Now suppose your classmates as a node which has a copy of the
				record of transactions (here notes).</section>
			<section>And whenever anyone update the notes, he tells everyone in the class, that “Hey folks, I have added
				new topic". Now node(student) near him will verify the note, and if it seems correct to them, they will
				update their note too, Same process goes for all the students.</section>
			<section>
				<h2 class="r-fit-text">Benefits of Blockchain</h2>
			</section>
			<section>In the centralized system one person or a group of people have control, but in the case of
				blockchain, it is decentralized, there are many node operators who connects the blockchain together.
			</section>
			<section>Suppose you are using a social media app, and that company decides to suspend your account without
				even informing you, Then?</section>
			<section>Another advantage of blockchain is its speed and efficiency, as the transactions here are verified
				by different node operators, time taken is much less.</section>
			<section> Blockchain is immutable, which means they can’t be changed and it is very good for security. There
				is also less counterparty risk.</section>
			<section data-autoslide="2000">
				<p class="fragment" data-fragment-index="1">Let's summarize the benefits of blockchain</p>
				<p class="fragment" data-fragment-index="2">Decentralized</p>
				<p class="fragment" data-fragment-index="3">Immutable</p>
				<p class="fragment" data-fragment-index="4">Speed and efficiency</p>
				<p class="fragment" data-fragment-index="5">No Counterparty risk</p>
				<p class="fragment" data-fragment-index="6">Much Secure</p>
			</section>
			<section>
				<h2 class="r-fit-text">P2P Network</h2>
			</section>
			<section>Suppose there are five nodes and each node has their copy of blockchain. If A does any transaction
				and adds the block to their chain, it will tell other nodes, that " Hey, I have added a block to my
				chain, please verify and add to yours too". Other nodes will verify the block and add it to their chain.
			</section>
			<section>
				<h2 class="r-fit-text">How blockchain work?</h2>
			</section>
			<section>Suppose there are 10 nodes in a Blockchain and you have done a transaction of 3 ETH for an apple
				for your friend. Now the miners would try to solve the mathematical problem and whoever solve the
				problem first will add the block to their copy.</section>
			<section>Now that node will send the message (layman) to other miners “Hey Dude, I have added this block,
				please add it to yours too”.</section>
			<section>Other nodes will verify the block before adding to their copy. Verification is faster than the
				mining. After the successful validation block will be added by the other nodes too. And the transaction
				will be successful.</section>
			<section>
				<h2 class="r-fit-text">Consensus Protocol</h2>
			</section>
			<section>As we know that anyone can store information on the blockchain therefore it is important that there
				are some rules that can ensure every nodes agrees on what to add and what to discard.</section>
			<section> These rules are called consensus protocols. It helps in verifying the transactions that they are
				not malicious. Some common types of consensus protocols are POW, POS.</section>
			<section>
				<h2 class="r-fit-text">Proof of work</h2>
			</section>
			<section>Proof of work (PoW) is a form of adding new blocks of transactions to a blockchain. The work, in
				this case, is generating a hash that matches the target hash for the current block. For this they have
				to solve a mathematical problem and the miner who does this first win rewards.</section>
			<section>
				<h2 class="r-fit-text">Proof of stake</h2>
			</section>
			<section>Proof of Stake (POS) is where there are validators not miners. Validators are selected randomly. If
				anyone want to become a validator, they have to stake ethers (min 32ETH), so after staking they are
				ready for attestation (simply attaching the blocks to the chain).</section>
			<section>If the validator, does it work correctly the staked ETH + Transaction fee will be returned to
				him/her. But if any malicious activity is done by the validator the staked ETH will also not be
				returned. The more staked amount more is the possibility of getting selected.</section>
			<section>
				<h2 class="r-fit-text">Byzantine General Problem</h2>
			</section>
			<section>Suppose there is a palace A and there are generals who have to attack this palace and these
				generals are from the same kingdom. They are located in different directions and they have to attack the
				palace A. They don't have any leader who will tell them when to attack, so they will work based on their
				intuition.</section>
			<section>They will send the message from their messenger that we can attack, same is done by all the
				generals, and they attack and win. Now this seems this easy, but suppose if one general is a traitor
				then? So, all other generals will send the message that yes, we can attack but the traitor will send the
				message that NO we should not attack.</section>
			<section>This is the same problem we have in our Distributed System. Suppose the traitor is a hacker and it
				sends wrong data to the nodes and corrupt it. This problem was solved by Miguel Castro. Byzantine Fault
				Tolerance is the solution for Byzantine Generals Problem.</section>
			<section>
				<h2 class="r-fit-text">Byzantine Fault Tolerance</h2>
			</section>
			<section>Miguel says that the majority opinion should be followed, it does not matter what 1/3 nodes are
				saying in front of 2/3 nodes opinion.</section>
			<section>
				<h2 class="r-fit-text">Competing Chain Problem</h2>
			</section>
			<section>Suppose we have five nodes and every node has their blockchain, two nodes mined blocks on the same
				time. So new blocks are added to both of their chain. One block sent the info to their peers and they
				verify and add the block to their chain.</section>
			<section>Same other block has done. Now here occurs a conflict, and consensus protocol says that we will
				take the chain with more blocks, as a valid chain, and other will be discarded. The discarded blocks are
				also called as Orphan blocks.</section>
			<section>
				<h2 class="r-fit-text">What we will learn next?</h2>
			</section>
			<section>
				<div class="r-stack">
					<a href="https://docs.soliditylang.org/en/v0.8.11/">
						<img class="fragment r-frame"
							src="https://res.cloudinary.com/practicaldev/image/fetch/s--Rxmub8vz--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5jd65usaioipnkv5xs5a.png"
							width="500" height="400">
					</a>
					<img class="fragment"
						src="https://repository-images.githubusercontent.com/24655114/c71c5800-6a8c-11e9-9117-8ec357c9f69e"
						width="600" height="500">
					<img class="fragment"
						src="https://d33wubrfki0l68.cloudfront.net/fcd4ecd90386aeb50a235ddc4f0063cfbb8a7b66/4295e/static/bfc04ac72981166c740b189463e1f74c/40129/eth-diamond-black-white.jpg"
						width="500" height="400">
				</div>
			</section>
			<section
				data-background-image="https://images.fineartamerica.com/images-medium-large-5/multicolored-confetti-lauren-burke.jpg"
				data-preload>
				<h2 class="r-fit-text" data-transition="convex" style="color: black;">Thank You!</h2>
				<aside class="notes" data-markdown>
					#### Next Content topic to write on

					I am testing speaker notes
				</aside>
			</section>
		</div>
	</div>
	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		Reveal.initialize({
			hash: true,
			controlsTutorial: true,
			progress: false,
			touch: true,
			help: true,
			showNotes: false,
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		}).then(() => {
			console.log("Presentation loaded");
		});
		Reveal.addKeyBinding({ keyCode: 84, key: 'T', description: 'Start timer' }, () => {
			// start timer
		});
	</script>
</body>

</html>